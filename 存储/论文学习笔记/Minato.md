##### Minato总共分为两个机制：
1）读写缓存空间分配机制
2）读干扰缓解机制

##### 在缓存中设置读缓存，写缓存，虚读缓存，虚写缓存，虚过滤缓存
 读缓存：存储着热读数据,当热读数据过多时以致装不下时，用某种算法筛选。
写缓存：存储着热写数据，机制同上。
虚读缓存：接收从读缓存淘汰的数据。
虚写缓存：接收从写缓存淘汰的数据。
虚过滤缓存：被读干扰缓解机制过滤的数据保存在此

##### 读写缓存空间分配机制：
###### 目的：
一般SSD的缓存设计是没有读缓存空间的，但在某些情况，写缓存空间需求不用这么大，而要求读缓存空间，所以设计该算法根据请求的统计结果动态分配读写缓存空间。
###### 思路：
该机制配备一个滑动窗口，大小为n,其中存储近n次请求的情况，如写请求命中，读请求命中，写请求未命中，读请求未命中。滑动窗口滑动n次后，统计一次情况，（或者隔n次滑动一次，滑动距离n）来规划后n次请求的缓存分配情况。
![[Pasted image 20240824145034.png]]
统计情况满足上述式子是减少写缓存，增大读缓存空间的前提。注意这只是前提。满足该前提的情况下，再看虚写缓存命中情况，若命中，则不进行修改，否则减少写缓存，增大读缓存空间。
###### 具体流程：
整个机制在运行时分为两个阶段。
初始阶段：
开始全部分给写缓存，判断请求时否是写请求，是将写请求数据放入缓存，若不是写请求，增大读缓存，减小写缓存。重复上述操作直到缓存被填满。
平衡阶段：
若请求是读请求，则进入读干扰缓解机制。若请求是写请求，判断是否命中虚写缓存，若命中直接增大写缓存，并将数据放入写缓存。若没命中，且根据滑动窗口中的统计结果判断是否满足不等式，若满足，则增大读缓存。
##### 读干扰缓解机制：
###### 目的：
减小读干扰的影响。
###### 思路：
热读数据过多时（通过虚读缓存是否命中来判断），读缓存装不下，这个时候便需要做出选择，这时候选择读干扰大的热数据缓存到缓存中，读干扰小的热数据放进虚过滤缓存。
###### 具体流程：
filter_x大小设置为0，统计滑动窗口虚读缓存命中情况，若未命中，则不需要过滤，因为当前缓存足以承担热读数据。若命中，则需要提升filter_x的大小，与滑动窗口统计频率一样，每隔n次改变一次filter_x。那么下次热读数据想要进入缓存，则需要判断有效数据比的大小，若小于filter_x，则进入虚过滤 缓存。若大于，则按照正常缓存淘汰机制进入读缓存。


##### 整个minato流程图
![[minato.png]]