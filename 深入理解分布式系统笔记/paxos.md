#### basic paxos
==只能完成一个日志的复制==
角色分为：
客户端
提议者：提议者收到客户端的请求，提出相关提案，试图让接收者接受该提案，并在发生冲突时进行协调。
接受者：也叫投票者，既投票接受或拒绝提议者的提案，若超过半数的接收者接受提案，则提案被批准
学习者：学习者只能学习被批准的提案，不参与决议提案。
paxos分为两阶段
##### 第一阶段：
###### 发送RPC请求（prepare）
该阶段提议者收到来自客户端的请求后，选择一个最新的提案编号n，向超过半数的接受者广播prepare消息，请求接收者对提案进行投票。
###### 接收者收到prepare消息后进行判断:
如果prepare消息中的提案编号n大于之前接受的所有提案编号，则返回promise消息进行响应，并承诺不再接收编号小于n的提案。特别地，如果接收者之前接收了某个提案值，那么promise响应将前一次提案的编号和对应值发送给提议者。
否则忽略请求，或发出拒绝响应。
为了实现故障恢复，需要持久化已接受的最大提案编号，已接受的提案编号，和已接受的提案值。
##### 第二阶段：
当提议者收到超过半数的接受者的promise响应后，提议者向多数派的接收者发起accept请求，这次请求带上提案编号和提案值。
关于提案值的选择，如果接收者在第一阶段返回了它的已接受值和提案编号，提议者选择==提案编号最大==的==已接受值==作为提案值，如果没有返回，提议者可以自由决定提案值。


#### 活锁问题
FLP不可能定理对paxos依然生效。频繁的客户端请求使paxos算法一直停留在第一个阶段。
客户端第二个请求在客户端第一个请求还没完成pahse b的时候来到，会导致第一个请求的pahse b不能实现，因为节点会承诺不接受比第二个请求更小的提案编号和提案值。
解决办法：引入随机超时，某个提议者发现提案没有被成功接收，则等待一个随机超时时间，让出机会。

#### muti-paxos
 原本的单日志变成了日志数组
##### 领导者选举
使用最大serveID的节点作为领导者。若领导者的日志远远若后于其他节点，那么paxos需要重复发送多次第一阶段的消息以补齐领导者的日志。
##### 减少请求



  
