只要日志未被提交，即便已经是多数派，也是可以随便被修改或丢弃的。只有安全的日志才能被提交，但并非多数派的日志就是安全的。

##### 领导者选举的法则需要保证两个要点：
（1）如果节点的日志中没有正确提交的日志，则需要避免它成为领导者。
（2）被提交的日志必须出现在后续leader上。
下面两种方法可以解决上述难题。
###### 领导者选举与更替

选举期间选择最有可能包含所有已提交日志的节点作为领导者。
选择任期高以及索引高的节点。任期的优先级更高，若任期相等，选择索引更大的。
###### 延迟领导者提交之前任期的日志条目
该方法保证已被提交的日志必须出现在后续leader上。

==领导者只有提交自己任期内的日志后才能间接提交之前任期的日志。==如果之后客户端一直不发送新的写请求怎么办？使用no-op空日志，在领导者新上任后立即对其他跟随者发送no-op日志，得到半数支持后，就可以复制之前未被提交的任期日志并提交。
我们来分析为啥这样能保证，若有节点因为网络分区的原因没有收到no-op信息，则其肯定没有复制提交的节点，若之前的领导者宕机了，在网络分区中的节点因为没收到no-op，导致其最大任期小于系统中的任期，所以不会成功竞选领导者。能当上领导者的都是成功接收no-op日志的节点，而这些节点一定有正确的已提交日志。

接下来使用案例来进行分析。
情况如下，
![[IMG_20241015_114556.jpg]]
1、任期为2的日志条目一开始仅写在服务器S1，S2两个节点上，S1宕机后，S5收到S3，S4投票成为任期为3的领导者，由于网络分区的原因，任期3的领导者S5并不知道这些记录，S5创建了自己任期的三条记录后还未来的及复制就宕机。
2、之后任期4的领导者S1被选出。领导者S1试图与其他节点的日志进行匹配，因此它复制了任期2的日志到S3。尽管现在任期为2，索引为3的日志已经占多数，但它仍不安全，为什么呢？我们考虑下面这种情况，当任期为4的S1复制完任期为2，索引为3的日志后，并占大多数，提交完后便宕机。
3、此时S5会因为其任期为3，是所有节点最大的任期，被选为领导者，由于领导者此时索引为3的日志未被提交，那它将会复制自己索引为3的日志给其他跟随节点，得到超过半数支持后，再次提交。这就使得索引为3的日志提交了两次。这是分布式系统的禁忌。
为了解决上述问题，我们不能让满足多数派的日志立即提交，需延迟提交，我们采取发送no-op日志的方法，当no-op日志被大多数同意后，立即提交，之后才能提交之前领导者之前任期的日志。继续讨论上述情况，但这次我们改变提交策略。
1步骤不会改变，从2开始，任期为4的领导者S1上任后，先发送任期为4的no-op空白日志到其他节点，得到大多支持后便开始同步所有日志，若此刻没有网络分区，那么所有节点都会变成一样。若有网络分区，如S5没法收到no-op，且不会复制领导者的节点，那么即便S2提交完宕机，S5在恢复网络分区后会因为最大任期小不会当上领导者，而是那些进行完整复制的跟随者当上领导者。这就保证了后续领导者一定会有已提交的日志这一准则。
假设刚发送完no-op就宕机了，此时会再选出新的领导者，假设S5复制了任期为4的no-op，由于索引较大，那么S5将会被选上领导者，她也将发送no-op，任期为5，得到多数支持后，复制并提交前面未提交节点，索引为3，任期为3的节点得到复制并提交。

###### 日志复制
领导者会记录leaderCommit来表示最大提交索引号，并且在每次发送appendEntries时，携带给跟随者。
raft算法通过appendEntries消息来检测之前的一个日志条目：每个appendEntries消息请求包含新日志条目之前一个的日志条目索引prevLogIndex和任期prevLogTerm。跟随着收到请求后，会检查自己最后一条日志的索引和任期号是否与请求消息中的prevLogIndex，prevLogTerm相同。
###### 清理不一致的日志
由于网络分区的原因，可能会导致某个时刻系统内的日志信息混乱，许多跟随者的日志在恢复网络后与领导者的日志不一样。
领导者必须使跟随者的日志和自己保持一致。
领导者在给跟随者发送新的日志时，会携带上一次日志的索引和任期，试图匹配，若匹配失败则清理并继续往前匹配，直到匹配成功后开始补齐。
###### 处理旧领导者
因为网络分区的原因导致两个领导者同时工作，若此时网络分区恢复，若旧领导者收到客户端请求，会发送日志给其他节点，注意，每次RPC都会携带任期。
如果接受方发现发送方任期陈旧，则会将自己的任期回传给发送方，发送方发现自己任期过期从而转变成跟随者。
如果接收方发现自己任期陈旧，则将状态修改成跟随者，并正常处理RPC请求。

###### 客服端协议
领导者可能在提交日志后，响应客户端期间宕机，客户端收不到信息就会再次发起请求，就可能同一个请求执行两次。
解决办法是让客户端发送给领导者的每个请求都附加上唯一ID，领导者将唯一ID写入日志中。即便在响应客户端时宕机，客户端第二次发送请求，分布式系统也可以根据ID先查该请求是否已被提交，若提交则直接响应。
###### 实现线性一致性
###### 配置变更
