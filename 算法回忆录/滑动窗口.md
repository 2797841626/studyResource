


滑动窗口不一定是一个一个滑，若碰见匹配由几个相等长度的子串组成的字符串情况，则可以一次滑一个子串的长度。只不过在最外层再写个循环保证能覆盖所有情况。

##### 求取关于子串中的字母个数必须大于k这类问题
###### 暴力思路
直接枚举所有子串，但会碰到超时问题，其时间复杂度是O(n^2).
###### 优化思路：
我们可以利用字母总共只有26个来优化其时间复杂度
总共字母只有26个，说明字串的字母个数情况只有26种，可以有1个字母，或者2个，。。。或者26个。
我们就枚举字母个数，当有n个字母情况下，子串长度就必须大于等于n×k。根据情况进行滑动窗口去记录子串的情况。而且框定出现的字母种类数也给与滑动窗口盘点左指针右滑的条件。
```cpp
for(int k=1;k<=26;k++){
    left = 0;
    right = 0;
	while(right<size){
		while(字母种类数大于k){
		    left--
		}
	right++
	}
}
```
一般从左滑到右的复杂度为n
那么总复杂度为26n，尤其是对于长字符串效果最佳。

##### 求取关于子串中的字母个数必须小于k这类问题
可直接使用不定长滑动窗口，不需要考虑字母个数
```cpp
left = 0;
right = 0;
while(right<size){
	while(s[right]个数大于k && left<=right){
		left--
	}
	right++
	}
```
##### 逆向思维
当题目要求你移去数组或字符串两端的内容时求取最小操作数，可以逆向思维使用滑动窗口计算保留数组或字符串最大的情况。

###### 两段滑动窗口
当需要两段滑动窗口时，使用动态规划，在滑窗过程中利用数组去记录之前滑过的区间的值，比如存放曾经滑过的最大值，这样就可以边滑边求两段滑窗的最大值和了。

###### 给一个数组，求取数组在某区间内的个数，举一反三到其他题。



###### 给两个字符串是s,t，要求s中有一个字串，字串内有t出现过的所有字母，求最短子串。

这类题目明显是滑动窗口，但其中需要注意的是如何判断该子串中出现过的字母包含了t中的字母。且出现次数得大于等于t中的字母出现数量。
可以暴力，每次得到一个子串就遍历一遍去看是否以满足包含t中所有字母，并且字母出现的数量大于等于t中字母出现的数量，但该操作慢。
这里我们可以维护一个参数less，用一个变量 less 维护目前子串中有 less 种字母的出现次数小于 t 中这些字母的出现次数。当s中子串某个字母第一次满足t中相应字母的出现个数，则less--，直到less == 0. 移动left时，当移除了某个字母是t中的字母，则要判断移除它是否会影响less，影响了less则-1，一般只有第一次改变了t中相对应字母在s子串中的个数导致其小于t中该字母的个数时才-1。所以一般判断语句是 s_cnt[s[i]] == t_cnt[s[i]-1]是就-1。

##### 统计子数组个数
###### 越短越合法
通常伴有“最多”字样，要求满足数字（和，个数，种类）或字母（个数，种类）最多为多少的情况的子数组个数。
每找到一个满足情况的子数组，ans = ans + right-left+1；
解释：一个字符满足条件时ans = ans+1。两个字符满足条件时，子串个数再前者的数量上+2。三个字符满足条件时则再前者的数量上+3。
公式
```cpp
int left=0;
for(int right =0;right<nums.size();right++){
    数量++;
    while(数量超出了最多){
        减少数量;
        left++;
    }
    ans = ans + right-left+1;
}
```

###### 越长越合法
通常伴有“至少，最少”等字样，代表该子串越长越合法。要求满足该子串中的数字或字母至少有多少个。
每找到一个满足情况的子数组(子串)则 ans = ans + n-right;
解释：找到一个刚好满足情况的就代表加上其后缀组成的子数组也满足情况。
公式：
```cpp
int left=0;
for(int right =0;right<nums.size();right++){
    数量++;
    while(数量满足了至少的情况){
        ans = ans + n-right;
        减少数量;
        left++;
    }
}```
###### 恰好为多少
可转化为至多或至少的情况，然后相减。
注意：若题目有两个条件，其中之一的条件为至少，另一个条件为恰好，则将恰好条件转换为至少。

###### 求取重复字母最多子串的且给与k次修改机会类型的题目
这类题目与一般式滑窗不同，此处left的移动很难界定移到什么情况下停止。
正确做法：
维护一个历史满足条件的窗口内的出现相同字母数量的最大值Count，维护一个记录该窗口内字母数量的哈希表。
若（right-left+1-Count）<=k既满足条件，则继续向右滑，直到突破条件既right-left+1-Count>k
，此时left++，但同时right也++，保证窗口大小不变，直到出现下一个Count使得这个窗口能满足（right-left+1-Count）<=k。满足条件后right则继续右滑，left不变，滑到又不满足，则保证窗口大小不变平移右滑。以此往复。
代码公式：
```cpp
unordered_map<char,int> hash;
int maxCount=0;
int left = 0;
for(int right=0;right<s.size();right++){
    maxCount = max(maxCount,++hash[s[right]]);//记录历史最大值
    if(right-left+1-maxCount>k){
        hash[s[left]]--;
        left++;//保证窗口大小不变
    }
}
return right-left;
```
包括所有求最大长度的子串都可以使用这个方法，当不满足条件时就选择将窗口长度固定整体向右滑动，直到出现下一个满足条件的，再单独滑右指针。

