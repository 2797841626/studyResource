深度优先靠回溯
广度优先靠存储队列。

深度优先进行拓扑排序：
提示：
（1）需要设置visited数组，0表示未访问，1：表示正在访问，2表示以访问。何为以访问？既访问完此点以及它的所有后续点后，那么它便是以访问。在访问是访问完此点，但其后续点未访问完。
环的判断即使某点是在访问状态，但又访问回来了，那么便有了环。
通过visited数组可以判断是否有环
（2）使用深度优先不需要找入度为0的点，任意未访问点开始即可。
（3）使用逆向思维，通过深度优先找到最底下的点，然后入栈，并且将其标志为以访问，就算后面另一条通路再次访问到也不会判断为环。

邻接表建立

        `//建立图的链式存储`
      vector<vector<int>> picture;
        `picture.resize(numCourses);`

        `for(const auto& info: prerequisites){`

            `picture[info[1]].push_back(info[0]);`

        `}`
邻接表比邻接矩阵更快。