给你一个二维整数数组 `items` ，其中 `items[i] = [pricei, beautyi]` 分别表示每一个物品的 **价格** 和 **美丽值** 。items按price升序排列，如何求小于等于自己价格内的最大魅力值是多少？
遍历一便即可。
```cpp
        for (int i = 1; i < items.size(); ++i){
            items[i][1] = max(items[i][1], items[i-1][1]);
        }
```

##### 求最大子数组和问题
###### 前缀和法
###### 一般动态规划法
dp[i]保存包括i的最大子数组和，dp[i+1] = max(dp[i-1]+nums[i],nums[i])

###### 进阶写法去掉dp数组
用pre存储上次的i-1最大值，curr = max(pre+nums[i],nums[i])

###### 对于求数组最大和时，当你知道数组中必然有正数时可以换种写法。或者当最大数组求出来是负数你就不用。
```cpp
        int val=0;
        int ans=-INT_MAX;
        for(int i=0;i<nums.size();i++){
            val = val+nums[i];
            ans = max(ans,val);
            if(val<=0){
                val = 0;
            }
        }
```

##### 网格dp
###### 当正序出现思路复杂时考虑逆序
###### 当发现dp不能通过正常的由上到下，由左到右，或者由下到上，由右到左时，使用记忆化搜索DFS（回溯，带返回值的），当然得用一个二维矩阵存储搜索出来的极值，防止重复搜索。

###### 动态规划思考括号的合法性
将 `(`看成+1，`)`看成−1，那么括号序列合法当前仅当和为0且==所有前缀和非负==，因此只需要是用动态规划对每个点记录所有可能的前缀和。

##### 背包问题
vector<vector<int>> dp[i][j] ,数组序号i，背包容量为j，数组里存储的一般是多少个数。
看题目是不是选与不选问题，是就可以转换成背吧问题，然后去找选择的东西和背包容量即可。

最终容量限定，最多能背多少个

```cpp
dp[i][j] = max(dp[i-1][j],dp[i-1][j-nums[i]])
```
最终容量限定，有多少种背法

```cpp
dp[i][j] = dp[i-1][j]+dp[i-1][j-nums[i]]
```
最终容量限定，问能否背出容量为target的方案。
```cpp
dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]
```
拓展成
最终容量不限定（但最终容量有个最大值max），问在题目限定的条件下能确定的最终最大容量是多少。本质上就是问[0,max]中的多种可行的背包容量方案中，选择最大的那个 。

###### 0-1背包

###### 多重背包
物品可以重复选，有个数限制。
这类题一般使用一个哈希表或二维数组统计多少种数和每个数字的出现次数
因为数字可能有多个，一般是三层循环

```
for(int i=0;i<nums.size();i++){
	int cnt = nums[1];
	int score = nums[0];
	for(int j=0;j<=target;j++){
	    for(int k =0;k<cnt;k++){
	        dp[i][j]+=dp[i][j-k*score];
	    }
	}							 
}
```
第三层循环可以根据数学推导优化成：
cnt[x]是x的出现次数。
```
dp[i][j]=dp[i][j−x]+dp[i−1][j]−dp[i−1][j−(cnt[x]+1)⋅x]
```							 

##### 分组背包
分组背包在于一个组里只能选一个

##### 完全背包
   无个数限制